# 从输入 URL 到页面显示

这篇文章主要讨论从打开一个 url 到网页呈现的过程中，浏览器做了哪些事情？

从用户输入 http://www.banli17.com 开始。

http://www.banli17.com 是一个 URL，因为格式是统一的，所以当输入到浏览器地址栏回车的时候，浏览器知道如何进行处理。

## DNS 解析

浏览器会将 www.banli17.com 发送给 DNS 服务器，让它解析为 IP 地址。具体查找顺序如下：

1. 浏览器查找自身的 DNS 缓存。
2. 查找系统的 DNS 缓存。
3. 查找本地的 /etc/hosts 文件。
4. 发送 DNS 请求，如果路由器缓存中有则返回。
5. 查询运营商 DNS 服务器(ISP DNS)缓存。如果没有，则运营商会去做下面事情：
   - 运营商 DNS 服务器请求根 DNS 服务器，获得顶级域(com 域)的 IP 地址。
   - 运营商 DNS 服务器再请求顶级 DNS 服务器，获得权威域(banli17.com) 的 IP 地址。
   - 运营商 DNS 服务器再请求权威 DNS 服务器，获得主机的 IP 地址。
6. 将主机 IP 地址，并返回给客户端。

> 注：全球有 13 组根 DNS 服务器，负责返回顶级域 DNS 服务器的 IP 地址。顶级域 DNS 服务器，负责返回权威 DNS 服务器的 IP 地址。权威 DNS 服务器负责返回响应主机的 IP 地址。

## TCP 连接

解析到主机的 ip 地址后，就需要进行 TCP 连接了。TCP 连接的建立过程就是经典的三次握手。时序图如下：

![](/img/net/tcp3.jpg)

1. 服务端正在监听 80 端口。
2. 客户端发起 TCP 连接请求，会发送 SYN 信号，包信息是 seq = x，状态变为 SYN_SENT。
3. 服务器收到后将状态改为 SYN_RCVD(syn_received, 信号收到)，并返回 SYN,ACK 信号，seq=y, ack=x+1(确认收到客户端信号后加 1)。
4. 客户端收到信号后，返回 ACK 信号，包信息是 seq=x+1，ack=y+1。
5. 服务器收到数据后，即表示握手成功。
6. 开始进行数据传输。

> 三次握手实际是为了保证客户端和服务器相互知道对方有可以发送和接收数据的能力。第 3 步时，服务器知道客户端可以发送数据，第 4 步时，客户端知道服务器可以发送和接收数据(因为 ack=x+1)。第 5 步时，服务器知道客户端可以收到数据(因为客户端发送的数据是 ack=y+1)。

## HTTP 请求

### 请求的构建

TCP 连接后，就开始发送 HTTP 请求了。HTTP 请求报文的格式如下：

```
方法 URL HTTP版本号    ---- 请求行
key: value           -
key: value           | --- 请求头
key: value           -

body                 ---- 实体
```

可以通过命令`curl -v www.banli17.com`。`-v`表示显示详细信息。

具体请求报文信息如下：

```
> GET / HTTP/1.1
> Host: www.banli17.com
> User-Agent: curl/7.54.0
> Accept: */*
```

```
HTTP/1.1 301 Moved Permanently
Server: nginx/1.12.2
Date: Mon, 09 Sep 2019 03:26:17 GMT
Content-Type: text/html
Content-Length: 185
Connection: keep-alive
Location: https://www.banli17.com//blog
```

HTTP 请求报文格式构建完成后，浏览器会将它通过 socket 发给传输层。

### 请求的发送

HTTP 协议是基于 TCP 协议的，它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。到了 TCP 层，他会把二进制流变成一个报文段发给服务器。

在发送每个报文段时，都需要对方有一个回应 ACK，来保证报文可靠的到达了对方，如果没有回应，那么 TCP 层会进行重传，直到可以到达。

TCP 会给每个报文加上自己的端口和目标端口，将这两个信息放在 IP 头里面，交给 IP 层进行传输。

IP 层首先看自己的地址和目标地址是否在同一个局域网，如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放在 MAC 头，发送出去即可；如果不再同一个局域网，就需要发送到网关，还需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。

网关收到包发现 MAC 符合，去除目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳的路由器。

最终到达目标的局域网，这个时候，最后一个路由器能够发现，目标地址就在自己的某个出口的局域网上，于是，在这个局域网上发送 ARP，获得这个目标的 MAC 地址，将包发出去。

目标机器发现 MAC 地址符合，就将包收起来；发现 IP 符合，根据 IP 头协议，知道上一层是 TCP 协议，就解析 TCP 头，里面有序列号，看这个序列号是不是想要的，如果是就放入缓存，返回一个 ACK，如果不是就丢弃。

TCP 头里面还有端口号，HTTP 的服务器正在监听这个端口号，于是目标机器将包发给这个进程，HTTP 服务器进程看到这个请求是访问一个网页，于是就把网页发给客户端。

### 响应报文构建

HTTP 响应报文也是有格式的。

![](/img/net/http-res.png)

构建好响应的报文后，就将这个报文发送出去，还是通过 socket 发送给 TCP 层，将 TCP 将 HTML 分成一个个小段，并保证每个段都可靠到达。

这些段加上 TCP 头后会交给 IP 层，将刚才发送过程反着走一遍。

客户端发现 MAC 地址、IP 地址符合，就交给 TCP 层，根据序列号看是不是自己的报文段，如果是，就根据 TCP 头中的端口号，发给相应的进程，即浏览器，浏览器作为客户端也在监听某个端口。

浏览器拿到 HTTP 的报文，发现返回 200，一切正常，就从正文将 HTML 拿出来解析展示。

## 解析页面(渲染流程)

- html 由标签和文本组成。浏览器会根据标签的语义正确的展示 HTML 内容。
- 如果需要改变 html 的字体颜色、大小，就需要 css。它由选择器和属性构成。
- js 让网页动起来

按照时间顺序，流水线可以分成几个子阶段。

- 构建 DOM 树
- 样式计算
- 布局阶段
- 分层
- 绘制
- 分块
- 光栅化
- 合成

每个子阶段都有输入、处理、输出。

### 构建 DOM 树

浏览器无法直接理解和使用 HTML。所以需要将 HTML 转成 DOM 树。

输入是 HTML 文件。经过 HTML 解析器，输出 DOM。

HTML 的结构不太复杂，token 主要有开始标签、属性、结束标签、注释、CDATA 节点。比较麻烦的是需要做容错处理。

具体步骤如下：

1. 字符流解析成 token。通常的方案是使用状态机。
2. 根据 token 生成 DOM 树，可以使用栈。

### 样式计算

目的是为了计算出 DOM 节点中每个元素的具体样式。具体过程有三步：

1. 将 css 转成浏览器能够理解的结构 styleSheets。该结构能用于查询和修改。
   - css 来源有 link 引入的文件、style 标签内的 css、和元素属性内嵌的 css，每一部分都会生成一个 CSSStyleSheet 对象。存放在 StyleSheetList 中。
2. 转换样式表中的属性值，使其标准化。即将所有值转换为渲染引擎容易理解的、标准化的计算值。比如 em 转成 px，blue 转成 rbg(0,0,255)，bold 转成 700 等。
3. 计算 DOM 树中每个节点的具体样式。这个过程涉及 css 的继承规则和层叠规则。计算样式。
   - css 继承，就是每个 DOM 节点都包含父节点的样式。如果不提供样式，默认使用 UserAgent(浏览器默认) 样式。
   - 样式层叠

最终输出每个 DOM 节点的样式，并保存在 ComputedStyle 结构内。

### 排版(布局)

排版(布局)就是计算 DOM 树中可见元素的几何位置。chrome 布局阶段要完成两个任务：创建布局树和布局计算。

1. 创建布局树。DOM 树含有很多不可见的元素，比如 head 标签，还有使用 display:none 的元素。所以在显示之前，还要额外构建一棵只包含可见元素的布局树。大致工作如下：
   - 遍历 DOM 树中所有可见元素，并把这些节点加入到布局中。
   - 不可见的节点会被布局树忽略掉。
2. 布局计算。现在有了一棵完整的布局树，就要计算布局树节点的坐标位置。
   - 执行布局操作的时候，会把布局计算的结果重写写会到布局树中，所以布局树即是输入也是输出。chrome 正在进行重构，下一代布局系统叫 LayoutNG，视图将输入和输出进行分离，从而让布局算法更加简单。

## 分层

因为页面中有很多复杂的效果，如 3d、页面滚动、或者使用 z-indexing 做 z 轴排序，为了更方便的实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵图层树(LayerTree)。就像 PS 里的图层一样，叠加在一起构成最终页面图像。

选择`开发者工具 -> Layers`。

布局树和图层树之间的关系：通常，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，它会从属于父节点的图层。满足下面两点中的一点，就会新建图层：

1. 拥有层叠上下文属性的元素
   - `position: fixed`
   - `z-index: 2`
   - 滤镜：如`filter: blue(5px)`
   - `opacity: 0.5`
2. 需要裁剪 (clip) 的地方。比如父盒子装不下子盒子，渲染引擎会把子盒子内容的一部分显示在父盒子区域。如果有滚动条，滚动条也会提升为单独的层。

### 渲染和合成

### 绘制

图层树构建完成后，渲染引擎会对图层树中的每个图层进行绘制。

比如绘制一个盘子，上面有个苹果。会先绘制盘子，再绘制苹果。渲染引擎也是这样做的。

渲染引擎会将一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。

有时绘制一个元素都要好几条绘制指令，因为每个元素的背景，前景，边框等都需要单独指令去绘制。所以绘制阶段输出的是待绘制指令。

可以通过 Layer ，点击图片 ，Detail 下的 Profier 查看到绘制指令。

## 栅格化 (raster) 操作

绘制列表是用来记录绘制顺序和绘制指令的列表。实际的绘制操作是由渲染引擎中的合成线程来完成的。

当图层的绘制列表准备好之后，主线程会将绘制列表提交给合成线程。

如果绘制全部图层内容，开销太大，也没有必要，因为用户只会看到视口的内容。所以合成线程将图层划分为图块(tile)。这些图块通常大小是 `256 * 256` 或者 `512 * 512`。

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作由栅格化来执行，所谓栅格化，就是将图块转成位图。图块是栅格化执行的最小单位，渲染进程里维护了一个栅格化的线程池，所有的图块栅格化都是在线程池里执行的。

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

## 合成和显示

一旦所有图块都被栅格化，合成线程里就会生成一个绘制图块的命令：`DrawQuad`，然后将这个命令提交给浏览器进程。

浏览器进程里有个 viz 组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

## 浏览器组成

- 渲染引擎
  - html 解释器
  - css 解释器
  - 布局
- js 引擎
- 网络
- 存储
- 2D/3D 图形
- 音频和视频
- 图片解码器

渲染引擎

- chrome、opera: blink
- edge/ie: trident
- safari: webkit
- firefox: gecko

## 导航流程

> 从输入 URL 到页面展示，这中间发生了什么？

![](./imgs/1-4-1.png)

整个过程需要各个进程之间的配合。

- 浏览器进程主要负责用户交互、子进程管理和文件存储等功能。
- 网络进程是面向浏览器和渲染进程等提供网络下载功能。
- 渲染进程主要是把网络进程下载的 html、js、css、图片等解析为可以显示和交互的页面，因为渲染进程所有内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程的代码是不被信任的，渲染进程在安全沙箱里运行。

整个过程大致如下：

- 用户在浏览器进程里输入请求信息。
- 网络进程发起 URL 请求。
- 服务器响应 URL 请求之后，浏览器进程开始准备渲染进程。
- 渲染进程准备好之后，需要先向渲染进程提交页面数据，称为提交文档阶段。
- 渲染进程接受完文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。

这其中，用户发出 URL 请求到页面开始解析的过程，叫做导航。

### 1.用户输入。

用户输入时，地址栏会判断用户输入的是关键字，还是请求的 URL。如果是关键字，地址栏会使用浏览器默认搜索引擎来合成带搜索关键字的 URL。如果输入的内容符合 URL 规则，那么地址栏会根据规则，将内容加上协议，合成完整的 URL。

回车之后，浏览器刚开始加载地址，标签页图标进入加载状态，开始转圈。但是页面显示的内容还是之前的，需要等到提交文档阶段，页面内容才会被替换。

### 2.URL 请求过程

接下来，开始页面请求资源过程，浏览器进程会通过进程间通信(IPC)把 URL 请求发送给网络进程，网络进程收到 URL 请求后，发起真正的 URL 请求过程。

首先，网络进程查看本地缓存，如果有缓存，则直接返回给浏览器进程；如果没有，则进入网络请求流程，第一步是 DNS 解析，获取 IP 地址，如果请求协议是 HTTPS，则需要建立 TLS 连接。

然后，利用 IP 和服务器建立 TCP 连接，建立连接后，浏览器构建 http 报文。包括请求行、请求头等信息，并把 cookie 等数据附加在请求头中，发送给服务器。

服务器收到请求后，会根据请求信息生成响应数据，发送给网络进程，网络进程收到响应行和响应头后，开始解析响应头。

1. 重定向

网络进程发现状态码是 301 或 302，会从头的 Location 字段读取重定向地址，然后发起新的请求。

2. 响应数据的类型处理 content-type

它告诉浏览器返回的响应体数据是什么类型，如果是`application/octet-stream`(字节流)，浏览器会按照下载类型来处理，该请求会交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。如果是 HTML，浏览器会继续进行导航流程。

### 3.准备渲染进程

默认情况下，chrome 会给每个页面分配一个渲染进程，但是同一个站点（协议和顶级域名相同）会运行在一个渲染进程中，这个策略叫 process-per-site-instance。

在碰到`rel=noopener`属性时，它告诉浏览器新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。浏览器解析时，会新开一个渲染进程。

### 4.提交文档

渲染进程准备好之后，浏览器进程会发出`提交文档`的消息，渲染进程收到消息后，会和网络进程建立传输数据的管道，等文档数据传输完成后，渲染进程会发送`确认提交`消息给浏览器进程。浏览器进程收到`确认提交`消息后，会更新浏览器界面状态，包括安全状态、地址栏 URL、前进后退的历史状态，并更新 Web 页面。

### 5.渲染进程

一旦文档被提交，渲染开始页面解析和子资源加载。如果页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器收到后，会停止标签图标的加载动画。

> keep-alive 是为了解决连接效率不高的问题，http1.0 时代，http 请求都是短连接的形式，也即是每次请求一个资源都需要和服务器建立连接+传输数据+断开连接。为什么是 6 个请求而不是更多了，这是为了服务器性能考虑，如果同一时刻无限制连接，那么可能会导致服务器忙不过来。

## 渲染流程
