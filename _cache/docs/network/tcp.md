---
title: "网络协议之 TCP、UDP"
sidebar_label: TCP、UDP
---

## UDP

UDP (User Datagram Protocol,用户数据报协议)协议是面向无连接的，也就是说不需要在发送正式数据前创建连接。所谓的建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，用这样的数据结构来保证所谓的面向连接的特性。

UDP 的特点：

- 面向无连接，相信网络是美好的。
- 监听端口后，谁都可以传给它，它也可以传给别人(支持一对多、多对多、多对一、一对一)。
- 没有拥塞控制，UDP 一直以恒速发送数据，即使丢包也不管。
- UDP 对应用层报文直接打包，不进行拆分和拼接操作，因此，应用程序需要选择合适的报文大小。发送时，应用层将数据传递给传输层的 UDP 协议，UDP 只增加一个 UDP 协议标识，就传给网络层。接收时，UDP 去除 IP 报文头，就直接传递给应用层。

UDP 不保证有序、完整，没有控制流量的算法，相比 TCP 更加轻便，高效。

**UDP 头部**

UDP 头部只有 8 个字节，包含了以下几个数据:

- 两个十六位的端口号，分别为源端口（可选字段）和目标端口
- UDP 长度 (16 位)。
- UDP 检验和 (16 位) ，该字段用于发现头部信息和数据中的错误

**UDP 应用场景**

三大应用场景：

1. 需要资源少，在网络比较好的内网，或丢包不重要。
2. 不需要一对一建立连接，而是可以广播的应用。如 DHCP、VXLAN。
3. 需要处理速度快，延时低，可以容忍少数丢包，即使网络差，也不控制发送速度。

**UDP 实际应用场景**

1、 网页或者 APP 的访问

原来访问网页和手机 APP 都是基于 HTTP 协议的。HTTP 协议是基于 TCP 的，建立连接都需要多次交 互，对于时延比较大的目前主流的移动互联网来讲，建立一次连接需要的时间会比较长，然而既然是移 动中，TCP 可能还会断了重连，也是很耗时的。而且目前的 HTTP 协议，往往采取多个数据通道共享一 个连接的情况，这样本来为了加快传输速度，但是 TCP 的严格顺序策略使得哪怕共享通道，前一个不 来，后一个和前一个即便没关系，也要等着，时延也会加大。

而 QUIC(全称 Quick UDP Internet Connections，快速 UDP 互联网连接)是 Google 提出的一种基 于 UDP 改进的通信协议，其目的是降低网络通信的延迟，提供更好的用户互动体验。

QUIC 在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制。

2、流媒体的协议

直播协议大多使用 RTMP，它是基于 TCP 的。但是 TCP 会严格控制传输的正确性，它会保证上一个包收到了，下一个包才会确认。所以如果一个包没有收到，下一个包就算收到，在缓存里面，也需要等着。对直播来说，这显然不合适。直播，用户肯定关注的是最新的画面，而不是丢失的老旧画面，如果老是没来就等着，会卡着，新的画面也看不到，这会影响用户体验。(当然有的直播，用户希望能看到完整的视频)。

另外在网络不好时，TCP 会主动进行拥塞控制，降低发送速度，页面本来就卡，应该应用层马上重传，而不是主动让步。所以直播通常是使用 UDP 协议，然后在应用层控制包序，丢包是否重新发包，拥塞控制等。

3、实时游戏

实时游戏中，客户端和服务器需要建立长连接，保证实时传输数据。但是玩家很多，服务器却不多，由于维护 TCP 连接需要在内核维护一些数据结构，因而一台机器能够支撑的 TCP 连接数目。然后 UDP 由于是没有连接的，在异步 IO 机制引入之前，常常是应对海量客户端连接的策略。

另外还是 TCP 的强顺序问题，对战的游戏，对网络的要求很简单，玩家通过客户端发送给服务器鼠标和 键盘行走的位置，服务器会处理每个用户发送过来的所有场景，处理完再返回给客户端，客户端解析响 应，渲染最新的场景展示给玩家。

如果出现一个数据包丢失，所有事情都需要停下来等待这个数据包重发。客户端会出现等待接收数据， 然而玩家并不关心过期的数据，激战中卡 1 秒，等能动了都已经死了。

游戏对实时要求较为严格的情况下，采用自定义的可靠 UDP 协议，自定义重传策略，能够把丢包产生的 延迟降到最低，尽量减少网络问题对游戏性造成的影响。

4、物联网

一方面，物联网领域终端资源少，很可能只是个内存非常小的嵌入式系统，而维护 TCP 协议代价太大; 另一方面，物联网对实时性要求也很高，而 TCP 还是因为上面的那些原因导致时延大。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的。

5、移动通信领域

在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的。因为移动网络协议比较复杂， 而 GTP 协议本身就包含复杂的手机上线下线的通信协议。如果基于 TCP，TCP 的机制就显得非常多 余，这部分协议我会在后面的章节单独讲解。

UDP 虽然简单，但它有简单的用法。它可以用在环境简单、需要多播、应用层自己控制传输的地方。 例如 DHCP、VXLAN、QUIC 等。

## TCP

TCP 的特点是：

- 面向连接
- 每条 TCP 连接只能有两个断点 EP，只能一对一通信
- 面向字节流，将报文拆成字节流
- 可靠传输，使用流量控制和拥塞控制
- 首部最小 20 字节，最大 60 字节

**TCP 头部**

## 简介

大学计算机的核心课程: 计算机组成与系统结构、数据结构与算法、操作系统、计算机网络、编译原理

协议的三要素：

1. 语法
2. 语义
3. 顺序

比如计算机语言就是人类和计算机沟通的协议。

http 协议也是符合规则的。符合语法格式，每个内容都是有意义的，符合属性，点浏览器，浏览器发出 http 请求。

```
HTTP/1.1 200 OK
Date: Tue, 27 Mar 2018 16:50:26 GMT
Content-Type: text/html;charset=UTF-8
Content-Language: zh-CN
<!DOCTYPE html>
<html>
<head>
<base href="https://pages.kaola.com/" />
<meta charset="utf-8"/> <title> 网易考拉 3 周年主会场 </title>
```

下单的过程

1. 输入网址 URL，浏览器只知道名称，不知道地点，所以通过 DNS 协议或 HTTPDNS 查找。得到 ip 地址。ip 地址是互联网的门牌号。
2. 浏览器打包请求，通过 http 或 https 协议。DNS/HTTP/HTTPS 属于应用层。应用层的包交给传输层，通过 socket 编程实现。
3. 传输层有 2 种协议：无连接 UDP 协议，面向连接的 TCP 协议。面向连接就是保证包到达，否则重新发送直到。
4. TCP 协议头有 2 个端口，浏览器监听的端口，服务器监听的端口。操作系统通过端口判断包交给哪个进程。
5. 传输层封装完毕，浏览器将包交给操作系统的网络层。网络层协议是 IP 协议。IP 协议头里有源 IP 地址和目标 IP 地址。
6. 操作系统按照目标 IP 地址查找机器，它会判断 IP 地址是本地还是外地。
7. 操作系统启动时会被 DHCP 协议配置 IP 地址，以及默认的网关 IP 地址:192.168.1.1。
8. 操作系统通过 ARP 协议收到网关的 MAC 地址。
9. 操作系统将 IP 包交给 MAC 层，网卡将包发出去，因为包里有网关的 MAC 地址，所以能够送达网关。
10. 网关收到包，会根据路由表看下一步怎么走，局域网通过 MAC 地址通信。出了局域网就要通过 IP 了。
11. 网关通过路由协议(常用的 OSPF 和 BGP)看下一站怎么走，也要通过自己和下一个网关的 MAC 地址去下一个网关。
12. 最后一个网关知道这个包要去的地方，就会吼一声谁是目标 IP，目标服务器会回复一个 MAC 地址。网络包通过这个 MAC 地址找目标服务器。
13. 目标服务器发现 MAC 地址对上了，取下 MAC 发给操作系统网络层。
14. ip 对上了，取下 ip，ip 头里写着上一层封装的是 TCP 协议，将它交给 TCP 层。
15. TCP 层收到的每个包，都会回复收到了。
16. 如果发送端的 TCP 层没有收到回复，则会重新发送，直到收到。
17. TCP 头有目标端口号，通过端口号，找到监听该端口的进程如 Apache。进程得到 HTTP 进行处理。Apache 负责调度 php 或 mysql 等进行处理。调度是通过 RPC 调用。
18. Apache 发现都处理完了，会回复 https 包。

## 网络分层的含义

复杂的程序都要分层。封包和解包。

二层设备：处理 MAC 层
三层设备：处理 MAC 层和 IP 层。
四层 LB：
七层 LB 中层：

## ifconfig

查看 ip

- window: ipconfig
- linux: ifconfig,ip addr

linux 通过安装 net-tools 或 iproute2 可以运行这两个命令。

```
root@test:~# ip addr
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff
    inet 10.100.122.2/24 brd 10.100.122.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::f816:3eff:fec7:7975/64 scope link
       valid_lft forever preferred_lft forever
```

valid_lft = Valid Lifetime
preferred_lft = Preferred Lifetime

如上 10.10.122.2 就是一个 ip 地址，被分为 4 部分，每部分 8 个 bit，所以 ip 总共 32 位。但是现在计算机太多，这样的 ip 不够用。所以有了 IPv6，也就是上面的 fe80::f816:3eff:fec7:7975/64。这个有 128 位，现在就够用了。

32 位的 ip 不够用，还被分为了 5 类。

A: 0 + 7 位网络号 + 24 位主机号 0.0.0.0 - 127.255.255.255 16777214
B: 10 + 14 位网络号 + 16 位主机号
C: 110 + 21 位网络号 + 8 位主机号

无类型域间选路(CIDR)

这种方式将 IP 分为 2 部分，如上面的 10.100.122.2/24，后面的 24 表示前 24 位是网络号，后 8 位是主机号。

广播地址：10.100.122.255，发这个地址，所有 10.100.122 网络的机器都可以收到。
子网掩码：255.255.255.0

ip 和子网掩码进行 AND 计算，得到网络号：10.100.122.0

共有 IP 地址和私有 IP 地址

私有 IP 地址段允许组织内部自己管理。

计算第一个地址，子网掩码和广播地址。

16.158.165.91/22
16.158.101001 网络号 01.91 是机器号
第一个地址是 16.158.10100100.1 即 16.158.164.1
子网掩码 255.255.111111 00.0 即 255.255.252.0
广播地址 16.158.10100 11.255 即 16.158.167.255

ip 地址后面有个 scope，对于 eth0，是 global，说明王卡是可以对外的。对于 lo，是 host，表示只提供本机相互通信。

lo 全称是 loopback，环回接口，往往会分配到 127.0.0.1 地址，表示经过内核处理后直接返回，不会在任何网络中出现。

MAC 地址：fa:16:3e:c7:79:75，是网卡的物理地址，是 6 位的十六进制。

MAC 地址是唯一的，为了组网的时候，不同的网卡放在一个网络里可以不用担心冲突。

网络设备的状态标识：<BROADCAST,MULTICAST,UP,LOWER_UP> 叫做 net_device flags。

UP 表示网卡处于启动的状态，BROADCAST 表示网卡有广播地址，可以发送广播包，MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，即网线插着。MTU1500 表示以太网的默认最大传输单元 MTU 为 1500。

MTU 是二层 MAC，以太网规定 MAC 头加正文一起，不超过 1500 个字节。正文里有 IP 头，TCP 头，HTTP 头，如果放不下，就需要分片传输。

qdisc：queueing discipline，表示排队规则，内核通过某个网络接口发送数据包，需要按照这个规则将数据包加入队列。
pfifo: 对数据不进行处理，先进先出。
pfifo_fast: 队列包括三个波段(band)，每个波段先进先出，波段优先级分为三层 band0,band1,band2。

数据包是按照服务类型(Type of Service, TOS)被分配到三个波段的，TOS 是 IP 头里的一个字段，代表当前包是高优先级，还是低优先级。

## DHCP 与 PXE

### 配置 ip

通过命令行设置 ip 地址:

```bash
# net-tools
$ sudo ifconfig eth1 10.0.0.1/24
$ sudo ifconfig eth1 up

# iproute2
$ sudo ip addr add 10.0.0.1/24 dev eth1
$ sudo ip link set up eth1
```

旁边的机器是 192.168.1.x，我的配置 16.158.23.6，ping 192.168.1.6，结果就是包发不出去，因为 MAC 层没有填。

首先会判断源和目标的网段，不一样，所以发给网关，没有配置网关，则包发不出去，网关配置不成 192.168.1.6，因为网关和当前网络要在同一个网段。
不可能有台电脑，网管就配置下 IP。所以有了 DHCP。

DHCP `Dynamic Host Configuration Protocol`，动态主机配置协议。过程：

1. DHCP Discover: 一台新机器来，使用 IP0.0.0.0 发送一个广播包，目标 IP255.255.255.255，[BOOTP[UDP[广播包]]]，DHCP 就是 BOOTP 的增强版。BOOTP 头是 Boot request。
2. DHCP Offer: DHCP Server 根据机器的 MAC 地址判断它是新机器，回一个 IP 地址，也是广播，因为新机器没有 ip
3. 如果有多个 DHCP Server，新机器可能收到很多回复，一般选最先到的 DHCP Offer，并广播一个 DHCP Request，包含它的 MAC，接受的 IP，提供 IP 的 DHCP Server。这样其它 DHCP Server 就可以撤销提供的 ip。客户端 ip 还是 0.0.0.0
4. DHCP Server 收到广播后，会广播一个 DHCP ACK 消息包，表示接受客户机，并将 ip 信息和其它信息发给客户机。Boot reply。

IP 的收回和续期

客户机再租期过去 50%时，向 DHCP Server 发送 DHCP Request 包，收到 DHCP ACK 消息包，会根据新的租期和其它的 TCP/IP 参数更新配置。

PXE:预启动执行环境

机房需要给新机器自动安装操作系统。

1. 启动 BIOS，这是一个很小的系统，读取硬盘的 MBR 启动扇区，将 GRUB 启动起来，将权利给 GRUB。
2. GRUB 加载内核、加载作为根文件系统的 initramfs 文件，将权力给内核。
3. 内核启动，初始化操作系统。

安装系统只能在 BIOS 启动后，叫 Pre-boot Execution Environmen，PXE

PXE 需要一个 ip，通过 DHCP，DHCP 还可以配置 next-server，即 PXE 服务器地址、初始化启动文件 filename。

1. 启动 PXE 客户端，通过 DHCP 得到 ip、pxe 服务器地址、启动文件 pxelinux.0
2. 从 pxe 服务器下载启动文件，通过 TFTP 协议。所以 PXE 服务器上还有 TFTP 服务器。
3. pxe 客户端收到文件，执行。这个文件会指示 pxe 客户端向 TFTP 服务器请求计算机配置信息 prelinux.cfg。里面有内核在哪里，initramfs 在哪里。pxe 客户端会请求这些文件。
4. 启动 linux 内核。

## 从物理层到 MAC 层

第一层：物理层
电脑连电脑

- 1-3、2-6 交叉接法，12 收信号，36 发信号。
- 配置成一个网络：配置相同 ip、子网掩码和默认网关
  Hub: 集线器，在物理层工作，会把收到的数据都复制到其它端口。广播模式

第二层：数据链路层

Hub 要解决的问题：
**1. 包发给谁的，谁收**

链路层地址，因为在第二层(处理媒体访问控制),所以常叫 MAC 地址。有了 MAC 地址，数据包在链路层广播，mAC 网卡就能发现，如果包是它的，就收进来。打开 ip 包，也是自己的，再打开 TCP 包，端口是自己，80 就给 nginx，nginx 返回网页，又层层封装。

**2. 都在发会不会混乱，谁先发谁后发**

MAC: MEDium Access COntrol 媒体访问控制，就是解决第 2 个问题，算法叫做多路访问。

解决 2 的方式

1. 信道划分：多个车道，你走你的我走我的
2. 轮流协议：现在你先发，等会我先发
3. 随机接入协议：先发出去，看到堵了，就回来，等会再去。 以太网是这种方式

**3. 发送出现错误怎么办**

以太网 Ethernet 是一种局域网技术。

以太网第二层最后是 CRC，循环冗余检测。通过 XOR 异或算法来计算包是否发送过程中出现错误。

ARP 协议：Address Resolution Protocol 是根据 IP 地址获取物理 MAC 地址的一个 TCP/IP 协议。本地有 ARP 表，发广播包问 IP 是 x 的 MAC 是啥，目标机器回复后，缓存 IP-MAC 映射。

ARP 欺骗，就是修改 IP-MAC 映射，把别人的 MAC 地址改成自己的，结果发的数据都发给了自己，然后自己在当路由，发给其它人。

Hub 机器多时数据太多有问题，交换机能智能记住哪个口对应的 MAC，这样第一次建立后，下次就可以直接发给对应的口，不需要每个口都发了。这个叫转发表。

用一张图总结一下学到的知识点：

(物理层到数据链路层)

## 交换机与 VLAN

### 拓扑结构

拓扑结构是指网络中各个站点相互连接的形式，多个交换机相连就形成了一个比较复杂的拓扑结构。

机器发广播的时候，交换机可以知道这个机器的方向，然后记住这个拓扑信息。

交换机工作在数据链路层，可以连电脑，也可以作为局域网的连接器。交换机的工作原理是：在端口成功连接时通过 ARP 协议学习 MAC 地址，保存一张交换表。之后只发对应的端口，而不是所有端口。

### 环路问题

交换机如果形成环路，本来机器 1 在交换机的左边，但是右边又收到了 1 的广播，以为它换了位置，就更新了。以次循环。

造成的影响

### 如何解决环路问题

将图中的环破了，生成树，生成树的算法叫做 STP，全称 Spanning Tree Protocol。

- Root Bridge:根交换机
- Designated Bridges: 指定交换机
- Bridge Protocol Data Units(BPDU)：网桥协议数据单元
- Priority Vector:优先级向量，就是一组 ID 数目，[Root Bridge ID, Root Path Cost, Bridge ID, Port ID]。

STP 工作流程：

1. 首先每个交换机分配一个 ID，这个 ID 表示优先级，网管可以给贵的分配高优先级。
2. 每个交换机使用网线相连，发送 BPDU，优先级高的管理优先级低的，进行合并。之后只有管理者能发 BPDU。
3. 优先级高的遇到优先级高的，组队归附。
4. 同门相遇，掌门与小弟相遇，就说明有环，可以升职；小弟与小弟相遇。
5. 掌门与其它帮派小弟相遇。如果掌门比小弟的掌门差，则会归属到小弟掌门边。
6. 不同门派小弟相遇，比掌门。

### 广播安全问题

因为广播会广播到所有人，可能会被抓到包。

- 物理隔离: 每个部门有单独的交换机，配置单独的子网，部门之间沟通通过路由器。
- 虚拟隔离：VLAN，或虚拟局域网。一个交换机可以连多个局域网。如果交换机支持 VLAN，可以取出第二层的头里的 VLAN ID(12 位)，只有 VLAN 相同的包，才会互相转发，不同 VLAN 的包是看不见的。交换机之间通过 Trunk 口连接，它可以转发任何 VLAN 的口。

用一张图片来总结：

## TCP

## tcp 协议

- [(传输层) TCP 协议](http://www.cnblogs.com/kzloser/articles/2582957.html)
- [TCP 协议详解](https://www.jianshu.com/p/ef892323e68f)
- [阮一峰 TCP 协议简介](http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html)

## 三次握手

http 是应用层协议，只有发包、收包的概念。发包和收包之间需要创建传输层的 Tcp 连接将它们连起来。

在一个 tcp 连接上可以发送多个 http 请求。http 1.0 是发送完就断开的。http2 是长连接，也就是后面的连接不需要再三次握手。

三次握手的目的是让客户端和服务端都知道对方有发包和收包的能力。过程是：

- SYN：表示同步序号，用来建立连接。
- Seq：数据包本身的序列号
- ACK：确认序号是否有效，如果 ack
- ack：期望对方继续发送的那个数据包的序列号

第一次握手：建立连接时，客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；

第二次握手：服务器收到 syn 包，必须确认客户的 syn（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；

第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。

完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念：

未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的 SYN 包（syn=j）开设一个条目，该条目表明服务器已收到 SYN 包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于 Syn_RECV 状态，当服务器收到客户的确认包时，删除该条目，服务器进入 ESTABLISHED 状态。

SYN-ACK 重传次数：服务器发送完 SYN－ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。

半连接存活时间：是指半连接队列的条目存活的最长时间，也即服务从收到 SYN 包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为 Timeout 时间、SYN_RECV 存活时间。

### TCP 两种攻击技术：

TCP 会话劫持和 SYN FLOOD（同步洪流）

**同步洪流**

当客户端和服务器在网络中使用 TCP 协议发起会话时，在服务器内存中会开辟一小块缓冲区来处理会话过程中消息的“握手”交换。会话建立数据包包含一个 SYN 片段，用于标识消息交换中的序列号。而 SYN FLOOD 试图摧毁这一过程。攻击者快速发送一连串连接请求，之后并不响应服务器发送回来的应答，造成三次握手无法完成，在服务器上留下半打开的连接，分配给他们的缓存也被保留下来，使其他程序不能使用服务器。尽管缓冲区中的数据包在没有应答超过一段时间（通常 3min）就会被丢弃，但大量虚假请求的后果是用于建立会话的合法请求难以建立。

## 缓存

与缓存相关的字段

cache-control: max-age=20 优先级高于 expires 相对时间
expires: 绝对时间，格林尼治时间
last-modified: 文件最后修改时间
Etag

if-modified-since: 文件最后修改的时间
if-None-Match
浏览器缓存的逻辑流程

## DNS

如何通过域名找 IP

- [http 协议](http://www.cnblogs.com/TankXiao/category/415412.html)
- [前端代码异常日志收集与监控](http://www.cnblogs.com/hustskyking/p/fe-monitor.html)
- [白话 HTTPS & SSL/TLS](https://www.jianshu.com/p/992bad24412e)
- [http2 讲解](https://ye11ow.gitbooks.io/http2-explained/content/)
