## 数组

- 数组在内存一般是连续存储的。
- 通过索引可以获取对应位置的元素。索引从 0 开始。

常用操作

- 数组的创建
- 数组的遍历

数组的索引可以有语义，也可以没有。比如 `scores[0] = 100` 里的 0 设计为有语义可以表示 id 为 0 的学生成绩。如果设计为没有语义则可以表示随便某个同学的成绩。
数组的优点：快速查询
数组最好设计为有语义的情况。
不过不是所有有语义的索引都适用于数组。比如身份证号 11111111111111，太大了，需要开辟那么大的空间，而且也没有像比较短的 66 的身份证号，这空间就都浪费了。

java 中数组的问题？

- 初始化后大小就固定了，不能变
- 如初始化了长度为 8 的数组，但是只用了前三个，后面的没有元素的如何表示。
- 如何添加、删除元素？

封装自己的动态数组。增删改查。
size 表示数组中下一个没有元素的索引。比如初始化一个长度为 3 的数组，都是 empty，size 为 0，设置第一个元素后，size+1。
size 同时也表示数组中有多少个元素。
插入元素
向数组的末尾插入
数组维护了一个 size，初始化数组时，size 为 0。插入元素时只需要改变 size 处的元素，然后让 size +1 。
向指定位置插入
指定位置处以及后面的元素都往后移动一位，然后插入，最后 size+1。

查询元素: `get(index)`
修改元素: `set(index, e)`
包含元素：`contains(e)`
查找索引：`find(e)`，没有找到就是 -1
删除元素：

- `remove(index)`让后面的元素左移动一位，然后 size -1。
- `removeFirst()`
- `removeLast()`
- `removeElement(e)`

  ![](./imgs/2021-05-29-11-22-26.png)
  上图中，删除元素完成后，size 处的元素是 100，没有影响，因为内部会判断索引的合法性，用户只能获取 [0, size) 的值，获取不到 size 处的值。另外 java 中数组初始化后，元素有初始值就是 0，这些默认值对用户是不可见的。
  操作

- 获取：通过 Memory Controller(内存管理器)访问任何下标位置的元素为 O(1)。
- 插入: 因为要保证是连续的，所以插入后，后面的元素要往后面移动。时间复杂度是 O(n) 的。
- 删除: 也是 O(n) 的。

java 数组的扩容：

增加元素时，如果 size 等于 capacity 了，就新建一个容量为 2 倍的数组，然后将旧数组中的数据拷贝到新的数组中，最后让 data 的引用指向这个新的数组。
在删除元素时，也用同样的技术来缩减空间。

时间复杂度分析：

- addLast(e) O(1)
- addFirst(e) O(n)
- add(index, e) O(n)

增 O(n)
删 O(n)
改 已知索引 O(1)；未知索引 O(n)，需要查询索引
查 已知索引 O(1)；未知索引 O(n)
resize 是 O(n) 的，但是不会每次都触发，索引 addLast 均摊时间复杂度 O(1)

复杂度震荡，但是如果重复进行 addLast，然后 remove，在边缘情况下，会导致每次都 resize，这导致复杂度升高到 O(n)。出现这个问题的原因是 remove 时 resize 过于着急。解决方法时 lazy remove。也就是当 size 降低到 1/4 时，resize 到原 size/2。这样可以 remove 时懒降容，且还剩下一些容量可供增加元素。
